// Code generated by go-bindata.
// sources:
// templates/includes/base.html
// templates/includes/footer.html
// templates/includes/header.html
// templates/index.html
// templates/ipinfo.html
// templates/whois.html
// assets/app.css
// DO NOT EDIT!

package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"time"
)
type asset struct {
	bytes []byte
	info  os.FileInfo
}

type bindataFileInfo struct {
	name    string
	size    int64
	mode    os.FileMode
	modTime time.Time
}

func (fi bindataFileInfo) Name() string {
	return fi.name
}
func (fi bindataFileInfo) Size() int64 {
	return fi.size
}
func (fi bindataFileInfo) Mode() os.FileMode {
	return fi.mode
}
func (fi bindataFileInfo) ModTime() time.Time {
	return fi.modTime
}
func (fi bindataFileInfo) IsDir() bool {
	return false
}
func (fi bindataFileInfo) Sys() interface{} {
	return nil
}

var _templatesIncludesBaseHtml = []byte(`{{ define "base" }}
{{ template "header" .}}
{{ template "content" .}}
{{ template "footer" .}}
{{ end }}
`)

func templatesIncludesBaseHtmlBytes() ([]byte, error) {
	return _templatesIncludesBaseHtml, nil
}

func templatesIncludesBaseHtml() (*asset, error) {
	bytes, err := templatesIncludesBaseHtmlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "templates/includes/base.html", size: 106, mode: os.FileMode(420), modTime: time.Unix(1518602441, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _templatesIncludesFooterHtml = []byte(`{{ define "footer" }}
</body>
</html>
{{ end }}
`)

func templatesIncludesFooterHtmlBytes() ([]byte, error) {
	return _templatesIncludesFooterHtml, nil
}

func templatesIncludesFooterHtml() (*asset, error) {
	bytes, err := templatesIncludesFooterHtmlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "templates/includes/footer.html", size: 48, mode: os.FileMode(420), modTime: time.Unix(1518602441, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _templatesIncludesHeaderHtml = []byte(`{{ define "title" }}
Checkbot
{{ end }}
{{define "header" }}
<!DOCTYPE html>
<html>
	<head>
		<title>{{template "title" . }}</title>	
	<link type="text/css" rel="stylesheet" href="assets/app.css">
	</head>
{{ end }}
`)

func templatesIncludesHeaderHtmlBytes() ([]byte, error) {
	return _templatesIncludesHeaderHtml, nil
}

func templatesIncludesHeaderHtml() (*asset, error) {
	bytes, err := templatesIncludesHeaderHtmlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "templates/includes/header.html", size: 216, mode: os.FileMode(420), modTime: time.Unix(1518602441, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _templatesIndexHtml = []byte(`{{ define "title" }}Список ботов{{ end }}
{{ define "content" }}
    <table class="table-bot">
        <tr>
            <th>#</th>
			<th>IP</th>
			<th><a href="?sort=hits">Hits</a></th>
			<th><a href="?sort=valid">Valid hits</a></th>
			<th>Checked</th>
			<th>Result</th>
			<th><a href="?sort=bytes">Down</a></th>
			<th colspan="3">Actions</th>
        </tr>
        {{with .Items}}
        {{range $index,$elem := .}}
            <tr>
                <td>{{$index}}</td><td>{{.IP}}</td>
                <td>{{.Hits}}</td>
                <td>{{.WhiteHits}}</td>
                <td>{{if .Checked}}YES{{end}}</td>
                <td class="{{if .White}}good-cell{{end}}{{if .Banned}}bad-cell{{end}}">{{if .White}}+{{end}}{{if .Banned}}-{{end}}</td>
                <td>{{.Bytes|mgb}}</td>
                <td><a href="/info/ip?find={{.IP}}">view log</a></td>
                {{if .Banned}}
                    <td class="bad-cell"><a href="/info/ip/ban?ip={{.IP}}&action=unban">unban</a></td>
                {{else}}
                    <td class="good-cell"><a href="/info/ip/ban?ip={{.IP}}&action=ban">ban</a></td>
                {{end}}
                <td><a href="/info/whois?ip={{.IP}}">whois</a></td>
            </tr>
        {{end}}
        {{end}}
    </table>
    <div class="paginator">
        {{range $index, $page := .Pages}} 
            <a href="/info/?p={{$page}}">{{$page}}</a>
        {{end}}
    </div>
  {{end}}`)

func templatesIndexHtmlBytes() ([]byte, error) {
	return _templatesIndexHtml, nil
}

func templatesIndexHtml() (*asset, error) {
	bytes, err := templatesIndexHtmlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "templates/index.html", size: 1453, mode: os.FileMode(420), modTime: time.Unix(1518605331, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _templatesIpinfoHtml = []byte(`{{ define "title"}}Поиск шаблона {{.Pattern}} в логах{{ end }}
{{ define "content" }}
<h1>Поиск {{.Pattern}}</h1>
{{if .Pattern|validIP}}
	<h3><a href="/info/whois?ip={{.Pattern}}">Проверка WHOIS</a></h3>
{{end}}
	<div class="fast-access">
		<div>Быстрый переход</div>
			{{range $logfile, $data := .Matches}}

				{{ if $data }}
				<div><a href="#{{ $logfile }}">{{$logfile}}</a><sup>{{ $data|len}} найдено</sup></div>
				{{ end }}
			{{ end }}
		</div>

		{{range $logfile,$data := .Matches}}
			{{ if $data }}
				<a name="{{$logfile}}"></a>
				
				<h2>в файле {{ $logfile }}</h2>
				{{ range $data}}
					<div> {{ . }}</div>
				{{end }} 
			{{end }}
		{{ end }}
{{ end }}
`)

func templatesIpinfoHtmlBytes() ([]byte, error) {
	return _templatesIpinfoHtml, nil
}

func templatesIpinfoHtml() (*asset, error) {
	bytes, err := templatesIpinfoHtmlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "templates/ipinfo.html", size: 740, mode: os.FileMode(420), modTime: time.Unix(1518845558, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _templatesWhoisHtml = []byte(`{{ define "title" }}Whois {{with .Item}}{{.IP}}{{ end }}{{end}}
{{ define "content" }}
    {{with .Item}}
    <h1>
        Whois {{.IP}}
        {{if .Banned}} <sup>Banned</sup> {{end}}
    </h1>
    <h3><a href="/info/ip?find={{.IP}}">Смотреть лог</a></h3>
    {{end}}
    {{.Whois|nl2br}}
{{ end }}
`)

func templatesWhoisHtmlBytes() ([]byte, error) {
	return _templatesWhoisHtml, nil
}

func templatesWhoisHtml() (*asset, error) {
	bytes, err := templatesWhoisHtmlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "templates/whois.html", size: 312, mode: os.FileMode(420), modTime: time.Unix(1518608169, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _assetsAppCss = []byte(`body{
	font-family: Arial, sans-serif;
	font-size:0.8em;
	line-height:18px;
}
.table-bot {
	border-collapse:collapse;
	border:1px solid #d4d4d4;
}
.table-bot td, .table-bot th{
	border-top:1px solid #d4d4d4;
	border-left:1px solid #d4d4d4;
	padding:10px;
	text-align:center;
}
.table-bot th, .table-bot th a{
	color:#002386;
}
.good-cell{
	background-color:#dff0d8;
}
.bad-cell{
	background-color:#ffc9c9;
}
.paginator {
	margin:20px 0px;
}
.paginator a {
	padding:5px;
}
.fast-access{
	border:1px solid #d4d4d4;
	padding:10px;
}
.fast-access sup{
	color:#6b6b6b;
	padding-left:3px;
}
`)

func assetsAppCssBytes() ([]byte, error) {
	return _assetsAppCss, nil
}

func assetsAppCss() (*asset, error) {
	bytes, err := assetsAppCssBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "assets/app.css", size: 585, mode: os.FileMode(420), modTime: time.Unix(1518602441, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

// Asset loads and returns the asset for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func Asset(name string) ([]byte, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("Asset %s can't read by error: %v", name, err)
		}
		return a.bytes, nil
	}
	return nil, fmt.Errorf("Asset %s not found", name)
}

// MustAsset is like Asset but panics when Asset would return an error.
// It simplifies safe initialization of global variables.
func MustAsset(name string) []byte {
	a, err := Asset(name)
	if err != nil {
		panic("asset: Asset(" + name + "): " + err.Error())
	}

	return a
}

// AssetInfo loads and returns the asset info for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func AssetInfo(name string) (os.FileInfo, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("AssetInfo %s can't read by error: %v", name, err)
		}
		return a.info, nil
	}
	return nil, fmt.Errorf("AssetInfo %s not found", name)
}

// AssetNames returns the names of the assets.
func AssetNames() []string {
	names := make([]string, 0, len(_bindata))
	for name := range _bindata {
		names = append(names, name)
	}
	return names
}

// _bindata is a table, holding each asset generator, mapped to its name.
var _bindata = map[string]func() (*asset, error){
	"templates/includes/base.html": templatesIncludesBaseHtml,
	"templates/includes/footer.html": templatesIncludesFooterHtml,
	"templates/includes/header.html": templatesIncludesHeaderHtml,
	"templates/index.html": templatesIndexHtml,
	"templates/ipinfo.html": templatesIpinfoHtml,
	"templates/whois.html": templatesWhoisHtml,
	"assets/app.css": assetsAppCss,
}

// AssetDir returns the file names below a certain
// directory embedded in the file by go-bindata.
// For example if you run go-bindata on data/... and data contains the
// following hierarchy:
//     data/
//       foo.txt
//       img/
//         a.png
//         b.png
// then AssetDir("data") would return []string{"foo.txt", "img"}
// AssetDir("data/img") would return []string{"a.png", "b.png"}
// AssetDir("foo.txt") and AssetDir("notexist") would return an error
// AssetDir("") will return []string{"data"}.
func AssetDir(name string) ([]string, error) {
	node := _bintree
	if len(name) != 0 {
		cannonicalName := strings.Replace(name, "\\", "/", -1)
		pathList := strings.Split(cannonicalName, "/")
		for _, p := range pathList {
			node = node.Children[p]
			if node == nil {
				return nil, fmt.Errorf("Asset %s not found", name)
			}
		}
	}
	if node.Func != nil {
		return nil, fmt.Errorf("Asset %s not found", name)
	}
	rv := make([]string, 0, len(node.Children))
	for childName := range node.Children {
		rv = append(rv, childName)
	}
	return rv, nil
}

type bintree struct {
	Func     func() (*asset, error)
	Children map[string]*bintree
}
var _bintree = &bintree{nil, map[string]*bintree{
	"assets": &bintree{nil, map[string]*bintree{
		"app.css": &bintree{assetsAppCss, map[string]*bintree{}},
	}},
	"templates": &bintree{nil, map[string]*bintree{
		"includes": &bintree{nil, map[string]*bintree{
			"base.html": &bintree{templatesIncludesBaseHtml, map[string]*bintree{}},
			"footer.html": &bintree{templatesIncludesFooterHtml, map[string]*bintree{}},
			"header.html": &bintree{templatesIncludesHeaderHtml, map[string]*bintree{}},
		}},
		"index.html": &bintree{templatesIndexHtml, map[string]*bintree{}},
		"ipinfo.html": &bintree{templatesIpinfoHtml, map[string]*bintree{}},
		"whois.html": &bintree{templatesWhoisHtml, map[string]*bintree{}},
	}},
}}

// RestoreAsset restores an asset under the given directory
func RestoreAsset(dir, name string) error {
	data, err := Asset(name)
	if err != nil {
		return err
	}
	info, err := AssetInfo(name)
	if err != nil {
		return err
	}
	err = os.MkdirAll(_filePath(dir, filepath.Dir(name)), os.FileMode(0755))
	if err != nil {
		return err
	}
	err = ioutil.WriteFile(_filePath(dir, name), data, info.Mode())
	if err != nil {
		return err
	}
	err = os.Chtimes(_filePath(dir, name), info.ModTime(), info.ModTime())
	if err != nil {
		return err
	}
	return nil
}

// RestoreAssets restores an asset under the given directory recursively
func RestoreAssets(dir, name string) error {
	children, err := AssetDir(name)
	// File
	if err != nil {
		return RestoreAsset(dir, name)
	}
	// Dir
	for _, child := range children {
		err = RestoreAssets(dir, filepath.Join(name, child))
		if err != nil {
			return err
		}
	}
	return nil
}

func _filePath(dir, name string) string {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	return filepath.Join(append([]string{dir}, strings.Split(cannonicalName, "/")...)...)
}

