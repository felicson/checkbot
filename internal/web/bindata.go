// Code generated by go-bindata.
// sources:
// views/includes/base.html
// views/includes/footer.html
// views/includes/header.html
// views/index.html
// views/ipinfo.html
// views/processes.html
// views/whois.html
// assets/app.css
// DO NOT EDIT!

package web

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"time"
)

type asset struct {
	bytes []byte
	info  os.FileInfo
}

type bindataFileInfo struct {
	name    string
	size    int64
	mode    os.FileMode
	modTime time.Time
}

func (fi bindataFileInfo) Name() string {
	return fi.name
}
func (fi bindataFileInfo) Size() int64 {
	return fi.size
}
func (fi bindataFileInfo) Mode() os.FileMode {
	return fi.mode
}
func (fi bindataFileInfo) ModTime() time.Time {
	return fi.modTime
}
func (fi bindataFileInfo) IsDir() bool {
	return false
}
func (fi bindataFileInfo) Sys() interface{} {
	return nil
}

var _viewsIncludesBaseHtml = []byte(`{{ define "base" }}
{{ template "header" .}}
{{ template "content" .}}
{{ template "footer" .}}
{{ end }}
`)

func viewsIncludesBaseHtmlBytes() ([]byte, error) {
	return _viewsIncludesBaseHtml, nil
}

func viewsIncludesBaseHtml() (*asset, error) {
	bytes, err := viewsIncludesBaseHtmlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "views/includes/base.html", size: 106, mode: os.FileMode(420), modTime: time.Unix(1518602441, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _viewsIncludesFooterHtml = []byte(`{{ define "footer" }}
</body>
</html>
{{ end }}
`)

func viewsIncludesFooterHtmlBytes() ([]byte, error) {
	return _viewsIncludesFooterHtml, nil
}

func viewsIncludesFooterHtml() (*asset, error) {
	bytes, err := viewsIncludesFooterHtmlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "views/includes/footer.html", size: 48, mode: os.FileMode(420), modTime: time.Unix(1518602441, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _viewsIncludesHeaderHtml = []byte(`{{ define "title" }}
Checkbot
{{ end }}
{{define "header" }}
<!DOCTYPE html>
<html>
	<head>
		<title>{{template "title" . }}</title>	
	<link type="text/css" rel="stylesheet" href="assets/app.css">
	</head>
{{ end }}
`)

func viewsIncludesHeaderHtmlBytes() ([]byte, error) {
	return _viewsIncludesHeaderHtml, nil
}

func viewsIncludesHeaderHtml() (*asset, error) {
	bytes, err := viewsIncludesHeaderHtmlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "views/includes/header.html", size: 216, mode: os.FileMode(420), modTime: time.Unix(1518602441, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _viewsIndexHtml = []byte(`{{ define "title" }}Список ботов{{ end }}
{{ define "content" }}
    <table class="table-bot">
        <tr>
            <th>#</th>
			<th>IP</th>
			<th><a href="?sort=hits">Hits</a></th>
			<th><a href="?sort=valid">Valid hits</a></th>
			<th>Checked</th>
			<th>Result</th>
			<th><a href="?sort=bytes">Down</a></th>
			<th colspan="3">Actions</th>
        </tr>
        {{with .Items}}
        {{range $index,$elem := .}}
            <tr>
                <td>{{$index}}</td><td>{{.IP}}</td>
                <td>{{.Hits}}</td>
                <td>{{.WhiteHits}}</td>
                <td>{{if .Checked}}YES{{end}}</td>
                <td class="{{if .White}}good-cell{{end}}{{if .Banned}}bad-cell{{end}}">{{if .White}}+{{end}}{{if .Banned}}-{{end}}</td>
                <td>{{.Bytes|mgb}}</td>
                <td><a href="/info/ip?find={{.IP}}">view log</a></td>
                {{if .Banned}}
                    <td class="bad-cell"><a href="/info/ip/ban?ip={{.IP}}&action=unban">unban</a></td>
                {{else}}
                    <td class="good-cell"><a href="/info/ip/ban?ip={{.IP}}&action=ban">ban</a></td>
                {{end}}
                <td><a href="/info/whois?ip={{.IP}}">whois</a></td>
            </tr>
        {{end}}
        {{end}}
    </table>
    <div class="paginator">
        {{range $index, $page := .Pages}} 
            <a href="/info/?p={{$page}}">{{$page}}</a>
        {{end}}
    </div>
  {{end}}`)

func viewsIndexHtmlBytes() ([]byte, error) {
	return _viewsIndexHtml, nil
}

func viewsIndexHtml() (*asset, error) {
	bytes, err := viewsIndexHtmlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "views/index.html", size: 1453, mode: os.FileMode(420), modTime: time.Unix(1518605331, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _viewsIpinfoHtml = []byte(`{{ define "title"}}Поиск шаблона {{.Pattern}} в логах{{ end }}
{{ define "content" }}
<h1>Поиск {{.Pattern}}</h1>
{{if .Pattern|validIP}}
	<h3><a href="/info/whois?ip={{.Pattern}}">Проверка WHOIS</a></h3>
{{end}}
	<div class="fast-access">
		<div>Быстрый переход</div>
			{{range $logfile, $data := .Matches}}

				{{ if $data }}
				<div><a href="#{{ $logfile }}">{{$logfile}}</a><sup>{{ $data|len}} найдено</sup></div>
				{{ end }}
			{{ end }}
		</div>

		{{range $logfile,$data := .Matches}}
			{{ if $data }}
				<a name="{{$logfile}}"></a>
				
				<h2>в файле {{ $logfile }}</h2>
				{{ range $data}}
					<div> {{ . }}</div>
				{{end }} 
			{{end }}
		{{ end }}
{{ end }}
`)

func viewsIpinfoHtmlBytes() ([]byte, error) {
	return _viewsIpinfoHtml, nil
}

func viewsIpinfoHtml() (*asset, error) {
	bytes, err := viewsIpinfoHtmlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "views/ipinfo.html", size: 740, mode: os.FileMode(420), modTime: time.Unix(1518845558, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _viewsProcessesHtml = []byte(`{{define "title"}}Список процессов хоста{{end}}
{{define "content"}}

<table class="table-bot">
    <thead>
        <tr>
            <th>PID</th>
            <th>Owner</th>
            <th>CPU %</th>
            <th>Mem %</th>
            <th> Process </th>
        </tr>
    </thead>
    {{with .}}
    {{range $index,$elem := .}}
        <tr>
            <td> {{.PID}} </td>
            <td> {{.User}} </td>
            <td> {{.CPU|float}} </td>
            <td> {{.Mem|float}} </td>
            <td> <span title="{{.Cmdline}}">{{.Name}}</span></td>
        </tr>
    {{end}}
    {{end}}
</table>
    
{{end}}`)

func viewsProcessesHtmlBytes() ([]byte, error) {
	return _viewsProcessesHtml, nil
}

func viewsProcessesHtml() (*asset, error) {
	bytes, err := viewsProcessesHtmlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "views/processes.html", size: 631, mode: os.FileMode(420), modTime: time.Unix(1540125892, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _viewsWhoisHtml = []byte(`{{ define "title" }}Whois {{with .Item}}{{.IP}}{{ end }}{{end}}
{{ define "content" }}
    {{with .Item}}
    <h1>
        Whois {{.IP}}
        {{if .Banned}} <sup>Banned</sup> {{end}}
    </h1>
    <h3><a href="/info/ip?find={{.IP}}">Смотреть лог</a></h3>
    {{end}}
    {{.Whois|nl2br}}
{{ end }}
`)

func viewsWhoisHtmlBytes() ([]byte, error) {
	return _viewsWhoisHtml, nil
}

func viewsWhoisHtml() (*asset, error) {
	bytes, err := viewsWhoisHtmlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "views/whois.html", size: 312, mode: os.FileMode(420), modTime: time.Unix(1518608169, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _assetsAppCss = []byte(`body{
	font-family: Arial, sans-serif;
	font-size:0.8em;
	line-height:18px;
}
.table-bot {
	border-collapse:collapse;
	border:1px solid #d4d4d4;
}
.table-bot td, .table-bot th{
	border-top:1px solid #d4d4d4;
	border-left:1px solid #d4d4d4;
	padding:10px;
	text-align:center;
}
.table-bot th, .table-bot th a{
	color:#002386;
}
.good-cell{
	background-color:#dff0d8;
}
.bad-cell{
	background-color:#ffc9c9;
}
.paginator {
	margin:20px 0px;
}
.paginator a {
	padding:5px;
}
.fast-access{
	border:1px solid #d4d4d4;
	padding:10px;
}
.fast-access sup{
	color:#6b6b6b;
	padding-left:3px;
}
`)

func assetsAppCssBytes() ([]byte, error) {
	return _assetsAppCss, nil
}

func assetsAppCss() (*asset, error) {
	bytes, err := assetsAppCssBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "assets/app.css", size: 585, mode: os.FileMode(420), modTime: time.Unix(1518602441, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

// Asset loads and returns the asset for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func Asset(name string) ([]byte, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("Asset %s can't read by error: %v", name, err)
		}
		return a.bytes, nil
	}
	return nil, fmt.Errorf("Asset %s not found", name)
}

// MustAsset is like Asset but panics when Asset would return an error.
// It simplifies safe initialization of global variables.
func MustAsset(name string) []byte {
	a, err := Asset(name)
	if err != nil {
		panic("asset: Asset(" + name + "): " + err.Error())
	}

	return a
}

// AssetInfo loads and returns the asset info for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func AssetInfo(name string) (os.FileInfo, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("AssetInfo %s can't read by error: %v", name, err)
		}
		return a.info, nil
	}
	return nil, fmt.Errorf("AssetInfo %s not found", name)
}

// AssetNames returns the names of the assets.
func AssetNames() []string {
	names := make([]string, 0, len(_bindata))
	for name := range _bindata {
		names = append(names, name)
	}
	return names
}

// _bindata is a table, holding each asset generator, mapped to its name.
var _bindata = map[string]func() (*asset, error){
	"views/includes/base.html":   viewsIncludesBaseHtml,
	"views/includes/footer.html": viewsIncludesFooterHtml,
	"views/includes/header.html": viewsIncludesHeaderHtml,
	"views/index.html":           viewsIndexHtml,
	"views/ipinfo.html":          viewsIpinfoHtml,
	"views/processes.html":       viewsProcessesHtml,
	"views/whois.html":           viewsWhoisHtml,
	"assets/app.css":             assetsAppCss,
}

// AssetDir returns the file names below a certain
// directory embedded in the file by go-bindata.
// For example if you run go-bindata on data/... and data contains the
// following hierarchy:
//     data/
//       foo.txt
//       img/
//         a.png
//         b.png
// then AssetDir("data") would return []string{"foo.txt", "img"}
// AssetDir("data/img") would return []string{"a.png", "b.png"}
// AssetDir("foo.txt") and AssetDir("notexist") would return an error
// AssetDir("") will return []string{"data"}.
func AssetDir(name string) ([]string, error) {
	node := _bintree
	if len(name) != 0 {
		cannonicalName := strings.Replace(name, "\\", "/", -1)
		pathList := strings.Split(cannonicalName, "/")
		for _, p := range pathList {
			node = node.Children[p]
			if node == nil {
				return nil, fmt.Errorf("Asset %s not found", name)
			}
		}
	}
	if node.Func != nil {
		return nil, fmt.Errorf("Asset %s not found", name)
	}
	rv := make([]string, 0, len(node.Children))
	for childName := range node.Children {
		rv = append(rv, childName)
	}
	return rv, nil
}

type bintree struct {
	Func     func() (*asset, error)
	Children map[string]*bintree
}

var _bintree = &bintree{nil, map[string]*bintree{
	"assets": &bintree{nil, map[string]*bintree{
		"app.css": &bintree{assetsAppCss, map[string]*bintree{}},
	}},
	"views": &bintree{nil, map[string]*bintree{
		"includes": &bintree{nil, map[string]*bintree{
			"base.html":   &bintree{viewsIncludesBaseHtml, map[string]*bintree{}},
			"footer.html": &bintree{viewsIncludesFooterHtml, map[string]*bintree{}},
			"header.html": &bintree{viewsIncludesHeaderHtml, map[string]*bintree{}},
		}},
		"index.html":     &bintree{viewsIndexHtml, map[string]*bintree{}},
		"ipinfo.html":    &bintree{viewsIpinfoHtml, map[string]*bintree{}},
		"processes.html": &bintree{viewsProcessesHtml, map[string]*bintree{}},
		"whois.html":     &bintree{viewsWhoisHtml, map[string]*bintree{}},
	}},
}}

// RestoreAsset restores an asset under the given directory
func RestoreAsset(dir, name string) error {
	data, err := Asset(name)
	if err != nil {
		return err
	}
	info, err := AssetInfo(name)
	if err != nil {
		return err
	}
	err = os.MkdirAll(_filePath(dir, filepath.Dir(name)), os.FileMode(0755))
	if err != nil {
		return err
	}
	err = ioutil.WriteFile(_filePath(dir, name), data, info.Mode())
	if err != nil {
		return err
	}
	err = os.Chtimes(_filePath(dir, name), info.ModTime(), info.ModTime())
	if err != nil {
		return err
	}
	return nil
}

// RestoreAssets restores an asset under the given directory recursively
func RestoreAssets(dir, name string) error {
	children, err := AssetDir(name)
	// File
	if err != nil {
		return RestoreAsset(dir, name)
	}
	// Dir
	for _, child := range children {
		err = RestoreAssets(dir, filepath.Join(name, child))
		if err != nil {
			return err
		}
	}
	return nil
}

func _filePath(dir, name string) string {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	return filepath.Join(append([]string{dir}, strings.Split(cannonicalName, "/")...)...)
}
